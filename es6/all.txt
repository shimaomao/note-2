let和const命令
es6中声明变量的方法
var function let const class import
不存在变量名提升
暂时性死区
不允许重复声明
let、const、class、import声明的变量不是全局对象的属性

变量的解构赋值
模式匹配，模式和变量
= 指定默认值
[x, y = 'b'] = ['a', undefined] //x='a', y='b'
var { message: msg = "Something went wrong" } = {};  msg //"Something went wrong"
如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
变量声明语句中，模式不能带有圆括号。
var [(a)] = [1]; //error
不能将整个模式，或嵌套模式中的一层，放在圆括号之中。
({ p: a }) = { p: 42 }; //error
赋值语句的非模式部分，可以使用圆括号。
({ p: (d) } = {}); //ok
如果要将一个已经声明的变量用于解构赋值，必须非常小心。JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。
var x;
{x} = {x: 1}; //error
({x} = {x: 1}); //ok
用途：
交换变量的值
从函数返回多个值
函数参数的定义
提取json数据
函数参数默认值
遍历map
引入其它模块指定方法

字符串的扩展
unicode表示
es5 \u20BB7 => \u20BB + 7 => 不可打印字符空格和7
es6 \u{20BB7}
js表示一个字符有6种方法：
'z'
'\z' === 'z'  // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
'\x7A' === 'z' // true
'\172' === 'z' // true  十进制表示法，码点
es5 chatAt(); charCodeAt(); String.fromCharCode();
es6 at(); codePointAt(); String.fromCodePoint();
codePointAt(); //返回十进制的码点，可通过toString(16)转换成十六进制
字符串实现了Iterator接口，for...of可以正确的识别32位utf-16字符
normalize(); 将字符的不同表示方法统一为一样的形式，即unicode正规化，目前只适用于欧洲文字，解决法语的重音符号之类的问题，且不能识别三个或三个以上字符的合成
参数：
NFC 标准等价合成
NFD 标准等价分解
NFKC 兼容等价合成 
NFKD 兼容等价分解
includes(str, index);
startWidth(str, index);
endWith(str, index); //此时index表示前index个字符 
repeat(num);
es7 字符串补全长度
padStart(len, str);
padEnd(len, str);
模板字符串 ``
变量 ${} 大括号内部，可以放任意js表达式，包括调用函数，如果是一个字符串，直接原样输出
es6 String.raw(str); 返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串。如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。
标签模板
模板字符串，可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。
var a = 5;
var b = 10;
function tag(stringArr, value1, value2) {//...}
tag `Hello ${ a + b } world ${ a * b }`; 等同于 tag(['Hello ', ' world ', ''], 15, 50);
第一个参数都一个raw属性，也指向该字符串数组，区别是raw属性里面的字符串斜杠都被转义了,strings.raw数组会将\n视为\和n两个字符，而不是换行符。
应用：
过滤html字符串，防止用户输入恶意内容
多语言转换（国际化处理）
在js语言之中嵌入其他语言

正则的扩展
es6,regexp构造函数可直接传入正则，第二个参数指定的修饰符会替换之前定义的修饰符
var a = new RegExp(/abc/ig, 'i').flags; //'i'
flags属性
u修饰符 unicode模式，用来正确处理大于\uFFFF的unicode字符  
y修饰符  粘连修饰符，与g修饰类似，y修饰符号隐含了头部匹配的标志ˆ，y修饰符的设计本意，就是让头部匹配的标志ˆ在全局匹配中都有效
sticky属性 表示是否设置了y修饰符，返回ture或false
RegExp.escape() 将普通字符串转义，使之正则化。未列入es7

数值的扩展
二进制 0b
八进制 0o  es5 严格模式不能使用0
转换成十进制 Number('0b11111');
Number.isFinite(); //只对数值有效  
Number.isNaN(); //只对数值有效
与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断
Number.parseInt();
Number.parseFloat();
Number.isInteger();  //只对数值有效，注意Number.isInteger(3.0);返回true
Number.EPSILON es6新增的一个极小常量 ，用作定义一个可接受的误差范围
Number.isSafeInteger(); //js可正确表示的整数范围，-2~53 ~ 2^53 （不包含两个端点）
Number.MAX_SAFE_INTEGER
Number.MIN_SAFE_INTEGER
Math.trunc(); //去除小数部分
Math.sign(); //判断一个数是正数、负数或是0，分别返回 ＋1，－1， 0
Math.cbrt(); //计算一个数的立方根
Math.clz32(); //返回一个32位无符号整数有多少个前导零
Math.imul(a, b); //返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数
Math.fround(); //返回一个数的单精度浮点数形式
Math.hypot(a, b, ...); //返回所有参数的平方和的平方根
Math.expm1(x); //返回ex/*x为下标*/ - 1，即Math.exp(x) - 1
Math.log1p(x); //返回1 + x的自然对数，即Math.log(1 + x)
Math.log10(x); //返回以10为底的x的对数
Math.log2(x); //返回以2为底的x的对数
Math.sinh(x); //返回x的双曲正弦
Math.cosh(x); //返回x的双曲余弦
Math.tanh(x); //返回x的双曲正切
Math.asinh(x); //返回x的反双曲正弦
Math.acosh(x); //返回x的反双曲余弦
Math.atanh(x); //返回x的反双曲正切
es7指数运算符 ** 
a ** 3  =>  a * a* a

数组的扩展
Array.from(); //将类似数组的对象（array-like object）和可遍历（iterable）的对象（包括es6新增的数据结构Set和Map）准换为数组，可正确处理4字节unicode字符
Array.from可以有第二个参数，类似map方法，Array.from([1, 2, 3], (x) => x * x);
扩展运算符 ...  可以将某些数据结构转为数组，背后调用的是遍历器接口（Symbol.iterator）
Array.of(); //用于将一组值，转换为数组，弥补，数组构造函数Array()因为参数个数的不同，而导致的行为差异
copyWithin(target, start = 0, end = this.length); //target，从该位置开始替换数据，start，从该位置开始读取数据
find(function (item, index, array) {}); //返回第一个符合条件的成员，可以发现NaN，弥补IndexOf方法的不足
findIndex(function (item, index, array) {});
fill(value, startIndex, endIndex); //不包括endIndex
entries();
keys();
values();
es7 includes(); //可以正确处理NaN(NaN === NaN)，弥补IndexOf方法的不足
es6明确将空位转为undefined
es7 数组推导，数组推导需要注意的地方是，新数组会立即在内存中生成。如果原数组是一个很大的数组，将会非常耗费内存
var a1 = [1, 2, 3, 4];
var a2 = [for (i of a1) i * 2];
a2 //[2, 4, 6, 8]

函数的扩展
函数参数的默认值
length属性，返回没有指定默认值的参数个数，不包括指定了默认值的参数
rest参数（剩余参数），用来替代arguments，函数的length属性，不包括rest参数
参数的扩展运算符...，将一个数组转为用逗号分隔的参数序列，不再需要apply方法，来将数组转为函数的参数，可正确识别32位unicode字符，可成功展开部署了iterator接口的对象
name属性，返回该函数的函数名，Function构造函数返回的函数实例，name属性的值为'anonymous',bind方法返回的函数，name属性值会加上'bound '前缀
箭头函数
如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回
由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号
箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
不可以使用arguments对象，该对象在箭头函数体内不存在
箭头函数不能用作Generator函数
this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。
箭头函数内部没有arguments、super、new.target三个变量
由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向
es7 函数绑定运算符::，双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面
foo::bar; 等同于 bar.bind(foo);
如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上、
尾调用，指某个函数的最后一步是调用另一个函数，不包含任何多余的操作
尾递归，尾调用自身
尾递归优化
一旦启用尾调用优化，func.arguments和func.caller这两个函数内部对象就失去意义了，因为外层的帧会被整个替换掉，这两个对象包含的信息就会被移除。严格模式下，这两个对象也是不可用的
纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现
es7提案，允许函数的最后一个参数有尾逗号，利于git等版本控制

对象的扩展
属性的简洁表示法，es6允许直接写入变量和函数，作为对象的属性和方法
setter 属性的赋值器,set
getter 属性的取值器,get
Generator *
属性名表达式，[]
注意，属性名表达式与简洁表示法，不能同时使用，会报错
方法的name属性，如果使用了取值函数，则会在方法名前加上‘get ’。如果是存值函数，方法名的前面会加上'set '。如果是一个Symbol值，那么name属性返回的是这个Symbol值的描述
Object.is(); 比较两个值是否严格相等，+0不等于-0，NaN等于自身
Object.assign(); 用来将源对象（source）的所有可枚举属性，复制到目标对象（target）,只拷贝自身属性，不可枚举的属性（enumerable为false）和继承的属性不会被拷贝，对于嵌套的对象，Object.assign的处理方法是替换，而不是添加
属性的可枚举性
对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为
let obj = { foo: 123 }; Object.getOwnPropertyDescriptor(obj, 'foo'); => { value: 123, writable: true, enumerable: true, configurable: true }
for...in 循环, 只遍历对象自身的和继承的可枚举的属性
Object.keys(); //返回对象自身的所有可枚举的属性的键名
JSON.stringify(); //只串行化对象自身的可枚举的属性
Object.assign(); //只拷贝对象自身的可枚举的属性
Reflect.enumerate(); //返回所有for...in循环会遍历的属性
es6规定，所有Class的原型的方法都是不可枚举的
属性的遍历，7种方法
for...in //for...in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）
for...of //不含Symbol属性
Object.keys(obj); //Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）
Object.getOwnPropertyNames(obj); //Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）
Object.getOwnPropertySymbols(obj); //Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性
Reflect.ownKeys(obj); //Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举
Reflect.enumerate(obj); //Reflect.enumerate返回一个Iterator对象，遍历对象自身的和继承的所有可枚举属性（不含Symbol属性），与for...in循环相同
__proto__属性，只有浏览器必须部署这个属性，其他运行环境不一定部署
Object.setPrototypeOf();
Object.getPrototypeOf();
Object.create();
Object.defineProperty(obj, mySymbol, { value: 'Hello!'});
es7提案，对象的扩展运算符，...

Symbol
js的数据类型
undefined，null，boolean，string，number，object，boolean
Symbol函数前不能使用new命令，因为它不是对象，它是一种类似于数组的数据类型
Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述
Symbol值不能与其他类型的值进行运算，Symbol值可以显式转为字符串，也可以转为布尔值，但是不能转为数值
Symbol值作为对象属性名时，不能用点运算符
Symbol.for('str'); //重新使用同一个Symbol值，会被登记在全局环境中供搜索，Symbol()不会，Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值
Symbol.keyFor(); //返回一个已登记(使用Symbol.for()而不是使用Symbol())的Symbol类型值的描述
内置的Symbol值
es6提供了11个内置的Symbol值，指向语言内部使用的方法
Symbol.hasInstance //instanceof运算符
Symbol.isConcatSpreadable //属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开
Symbol.species //指向一个方法。该对象作为构造函数创造实例时，会调用这个方法
Symbol.match //当执行str.match(myObject)时，如果该属性存在，会调用它
Symbol.replace //该对象被String.prototype.replace方法调用时，会返回该方法的返回值
Symbol.search //当该对象被String.prototype.search方法调用时，会返回该方法的返回值
Symbol.split //当该对象被String.prototype.split方法调用时，会返回该方法的返回值
Symbol.iterator //指向该对象的默认遍历器方法，即该对象进行for...of循环时，会调用这个方法，返回该对象的默认遍历器
Symbol.toPrimitive //该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值
Symbol.toStringTag //在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型
Symbol.unscopables //该对象指定了使用with关键字时，哪些属性会被with环境排除



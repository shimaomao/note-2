编译过程
预编译  // .h，.c
编译
汇编
链接  // 得到可执行文件

gcc  // GNU Compiler Collection
gcc -c hello.c  // 输出目标文件（.o/.obj），hello.o，编译器编译源代码但不执行链接
gcc -o hello.c hello  // 输出可执行文件hello，如果没有-o和后面的参数，gcc编译器默认输出a.out

静态链接库  // 在链接阶段，会将汇编生成的目标文件（.o/.obj）与引用到的库一起链接打包到可执行文件中
后缀名：
linux  .a  
windows  .lib
优点：
移植方便，程序在运行时与函数库再无关联
缺点：
浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成到一个可执行文件文件中，
不方便更新迭代，不能增量更新
linux创建静态库：
ar -crv libhello.a hello.o  // 需通过（ar/lib.exe）工具将目标文件打包成.a静态库文件

动态链接库  // 动态库在程序编译时并不会被链接到目标代码中，而是在程序运行是才被载入，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，动态库也称为共享库
后缀名:
linux .so 
windows .dll
优点：
节约空间和资源
方便更新迭代，可增量更新
缺点：
不方便移植
linux创建动态库：  // 不需要打包工具（ar/lib.exe），直接使用编译器即可创建动态库
gcc -fPIC -c hello.c  // 先生成目标文件，-fPIC，创建与地址无关的编译程序（pic，position independent code），为了能够在多个应用程序间共享
gcc -shared -o libhello.so hello.o  // 生成动态库，-shared，指定生成动态链接库
linux使用动态库：
gcc test.c -L../DynamicLibrary -lhello  // 引用动态库编译生成可执行文件的方法跟静态库一样，代码中需引用库的头文件。注意，linux动态库默认存放位置为/lib、/usr/lib，如果某动态库不在系统默认目录中，需要在系统中注册该动态库（ldconfig），否则编译器会找不到该动态库

指针，一种存放变量地址的变量，通常占用2或4个字节


编译过程
预编译  // .h，.c
编译
汇编
链接  // 得到可执行文件

gcc  // GNU Compiler Collection
gcc -c hello.c  // 输出目标文件（.o/.obj），hello.o，编译器编译源代码但不执行链接
gcc -o hello.c hello  // 输出可执行文件hello，如果没有-o和后面的参数，gcc编译器默认输出a.out

静态链接库  // 在链接阶段，会将汇编生成的目标文件（.o/.obj）与引用到的库一起链接打包到可执行文件中
后缀名：
linux  .a  
windows  .lib
优点：
移植方便，程序在运行时与函数库再无关联
缺点：
浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成到一个可执行文件文件中，
不方便更新迭代，不能增量更新
linux创建静态库：
ar -crv libhello.a hello.o  // 需通过（ar/lib.exe）工具将目标文件打包成.a静态库文件

动态链接库  // 动态库在程序编译时并不会被链接到目标代码中，而是在程序运行是才被载入，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，动态库也称为共享库
后缀名:
linux .so 
windows .dll
优点：
节约空间和资源
方便更新迭代，可增量更新
缺点：
不方便移植
linux创建动态库：  // 不需要打包工具（ar/lib.exe），直接使用编译器即可创建动态库
gcc -fPIC -c hello.c  // 先生成目标文件，-fPIC，创建与地址无关的编译程序（pic，position independent code），为了能够在多个应用程序间共享
gcc -shared -o libhello.so hello.o  // 生成动态库，-shared，指定生成动态链接库
linux使用动态库：
gcc test.c -L../DynamicLibrary -lhello  // 引用动态库编译生成可执行文件的方法跟静态库一样，代码中需引用库的头文件。注意，linux动态库默认存放位置为/lib、/usr/lib，如果某动态库不在系统默认目录中，需要在系统中注册该动态库（ldconfig），否则编译器会找不到该动态库

进程是操作系统资源分配的最小单元。操作系统分配给进程的内存空间中包含五种段：
数据段  // 存放程序中的静态变量和已初始化且不为零的全局变量
代码段  // 存放可执行文件的操作指令，代码段是只读的，不可进行写操作。这部分的区域在运行前已知其大小
bss  // block started by symbol，存放未初始化的全局变量，在变量使用前由运行时初始化为零
堆  // 存放进程运行中被动态分配的内存，其大小不固定
栈  // 存放程序中的临时的局部变量和函数的参数值

逻辑地址  // 与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须转化为物理地址
相对地址  // 特殊的逻辑地址，相对于某些已知点的存储单元
物理地址  // 数据在主存中的实际位置

几种内存管理技术
固定分区
动态分区
简单分页
简单分段
虚拟内存分页
虚拟内存分段

‘\0’ -> 0
' ' -> 32
'0' -> 48
'a' -> 97
'A' -> 65

#define指令行的末尾不可以有分号
c语言不可以在函数内部再定义函数

默认情况下，外部变量和静态变量被初始化为0，未经显式初始化的自动变量的值为未定义值（即无效值）

static声明的外部变量和函数，它们的作用域限定为被编译源文件的剩余部分，之前的部分，即使使用extern也无法访问
static声明的局部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量

const static == statci const
const限定符指定变量的值不能被修改，它本身是类型系统的一部分，类型匹配时需带上
const int *ptr = &x;  // 常量指针，ptr本身可变，但指向的内容不可变
int * const ptr = &x;  // 常量指针变量（变量的常量指针），ptr本身不可变，但指向的内容可变
const int * const ptr = &x;  // 指针常量（常量的常量指针），ptr本身不可变，指向的内容也不可变

register声明寄存器变量，只适用于自动变量以及函数的形式参数

根据定义，数组类型的变量或表达式的值是该数组第0个元素的地址，即arr实质上是&arr[0]
ptr = arr 等价于 ptr = &arr[0]  // ptr，指针变量名，一般情况下，用指针编写的程序比用数组下标编写的程序执行速度快。在计算数组元素arr[i]的值时，c语言实际上先将其转换为*(arr+i)的形式，然后再进行求值
&arr[i] 等价于 ptr + i
arr[i] 等价于 *(ptr + i)
数组名和指针之间有一个不同之处。指针是一个变量，因此，ptr = arr，ptr++都是合法的，但数组名不是变量，因此，arr = ptr，arr++都是非法的，但是arr + 1是合法的，因为并没有赋值
在函数定义中，形式参数char *arr等价于char arr[]，推荐使用前者，因为它更直观的表明该参数实质上是一个指针

*p++  // 先取值，后指针++
*++p  // 先指针++，后取值
++*p  // 先取值，后值++
(*p)++  // 先取值，后值++

void类型表示“没有值可以获得”

指针，一种存放变量地址的变量，通常占用2或4个字节
ANSI C使用类型void*代替char*作为通用指针的类型
对指针有意义的初始化值只能是0或者是表示地址的表达式，c语言保证，0永远不是有效的数据地址，因此，当指针的值为0时表示发生了异常事件
指针与整数类型之间不能相互转换，0是唯一的例外，常量0可以赋值给指针，指针也可以和常量0比较
程序中经常使用符号常量NULL代替0，NULL定义在标准头文件<stddef.h>中
在某些情况下，可以对指针进行比较运算，例如，对指向同一数组的两个指针进行比较，c语言对指向不同数组的两个指针之间的算术或比较运算没有定义
所有的指针运算都会自动考虑它所指向对象的长度，根据指向对象的长度按比例缩放

sizeof 对象  // 返回占用存储空间字节数，类型size_t，该类型在头文件<stddef.h>中定义，实质上是无符号整型数
sizeof(类型名)
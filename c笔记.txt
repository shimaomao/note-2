编译过程
预编译  // .h，.c
编译
汇编
链接  // 得到可执行文件

gcc  // GNU Compiler Collection
gcc -c hello.c  // 输出目标文件（.o/.obj），hello.o，编译器编译源代码但不执行链接
gcc -o hello.c hello  // 输出可执行文件hello，如果没有-o和后面的参数，gcc编译器默认输出a.out

静态链接库  // 在链接阶段，会将汇编生成的目标文件（.o/.obj）与引用到的库一起链接打包到可执行文件中
后缀名：
linux  .a  
windows  .lib
优点：
移植方便，程序在运行时与函数库再无关联
缺点：
浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成到一个可执行文件文件中，
不方便更新迭代，不能增量更新
linux创建静态库：
ar -crv libhello.a hello.o  // 需通过（ar/lib.exe）工具将目标文件打包成.a静态库文件

动态链接库  // 动态库在程序编译时并不会被链接到目标代码中，而是在程序运行是才被载入，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，动态库也称为共享库
后缀名:
linux .so 
windows .dll
优点：
节约空间和资源
方便更新迭代，可增量更新
缺点：
不方便移植
linux创建动态库：  // 不需要打包工具（ar/lib.exe），直接使用编译器即可创建动态库
gcc -fPIC -c hello.c  // 先生成目标文件，-fPIC，创建与地址无关的编译程序（pic，position independent code），为了能够在多个应用程序间共享
gcc -shared -o libhello.so hello.o  // 生成动态库，-shared，指定生成动态链接库
linux使用动态库：
gcc test.c -L../DynamicLibrary -lhello  // 引用动态库编译生成可执行文件的方法跟静态库一样，代码中需引用库的头文件。注意，linux动态库默认存放位置为/lib、/usr/lib，如果某动态库不在系统默认目录中，需要在系统中注册该动态库（ldconfig），否则编译器会找不到该动态库

指针，一种存放变量地址的变量，通常占用2或4个字节

进程是操作系统资源分配的最小单元。操作系统分配给进程的内存空间中包含五种段：
数据段  // 存放程序中的静态变量和已初始化且不为零的全局变量
代码段  // 存放可执行文件的操作指令，代码段是只读的，不可进行写操作。这部分的区域在运行前已知其大小
bss  // block started by symbol，存放未初始化的全局变量，在变量使用前由运行时初始化为零
堆  // 存放进程运行中被动态分配的内存，其大小不固定
栈  // 存放程序中的临时的局部变量和函数的参数值

逻辑地址  // 与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须转化为物理地址
相对地址  // 特殊的逻辑地址，相对于某些已知点的存储单元
物理地址  // 数据在主存中的实际位置

几种内存管理技术
固定分区
动态分区
简单分页
简单分段
虚拟内存分页
虚拟内存分段
生命周期
constructor   OnChanges   AfterContentInit      AfterViewInit      OnDestroy
              OnInit      AfterContentChecked   AfterViewChecked      
              DoCheck                      

示例：
<parent [value]="parent">
    <child-a [value]="childA"></child-a>
    <child-b [value]="childB"></child-b>
</parent>

组件初始化流程
parent constructor
child a constructor
child b constructor
parent ngOnChanges
parent ngOnInit
parent ngDoCheck
child a ngOnChanges
child a ngOnInit
child a ngDoCheck
child b ngOnChanges
child b ngOnInit
child b ngDoCheck
child a ngAfterContentInit
child a ngAfterContentChecked
child b ngAfterContentInit
child b ngAfterContentChecked
parent ngAfterContentInit
parent ngAfterContentChecked
child a ngAfterViewInit
child a ngAfterViewChecked
child b ngAfterViewInit
child b ngAfterViewChecked
parent ngAfterViewInit
parent ngAfterViewChecked
parent ngDoCheck
child a ngDoCheck
child b ngDoCheck
child a ngAfterContentChecked
child b ngAfterContentChecked
parent ngAfterContentChecked
child a ngAfterViewChecked
child b ngAfterViewChecked
parent ngAfterViewChecked    

组件更新流程
parent ngOnChanges  // 当通过外部传入到输入属性的值发生改变时触发，注意，在组件内通过程序直接改变输入属性值时不触发，ngOnChanges是否执行与变化检测无关
parent ngDoCheck
child a ngOnChanges
child a ngDoCheck
child b ngOnChanges
child b ngDoCheck
child a ngAfterContentChecked
child b ngAfterContentChecked
parent ngAfterContentChecked
child a ngAfterViewChecked
child b ngAfterViewChecked
parent ngAfterViewChecked 

组件销毁流程       
child a ngOnDestroy
child b ngOnDestroy
parent ngOnDestroy            

装饰器
@NgModule({
  declarations: [AppComponent],  // 声明本模块拥有的视图类，angular有3种视图类，组件、指令、管道（如：currentHero?.birthdate | date:'longDate'）
  exports: [AppComponent],  // declarations的子集，定义可在其它模块中使用的组件
  imports: [BrowserModule],  // 本模块组件模板中需要由其它模块导出的类
  providers: [Logger]  // 在模块providers中定义的服务，会被注册到根注入器，在应用中的任何部分都可被访问到，注意，懒加载模块中通过providers定义的服务，并未注册到根注入器，因此，这些服务只能在子模块中使用，另一种用法：useClass，useExisting（定义别名），useValue，useFactory
  bootstrap: [AppComponent]  // 标识出应用的主视图（被称为根组件），它是所有其它视图的宿主，只有根模块才能设置bootstrap属性
})

@Component({
  moduleId: module.id,  // 为与模块相关的url（如templateUrl）提供基地址
  selector: 'hero-list', 
  templateUrl: 'hero-list.component.html',  // 另一种用法template
  styleUrls: ['./style.scss'],  // 另一种用法style
  providers: [HeroService],  // 在组件providers中定义的服务，只在该组件及其各级子组件中可用
  pipes: [LowercasePipe],
  directives: [Tooltip],
  animations: [fadeAnimation],
  changeDetection: ChangeDetectionStrategy.OnPush,  // 变化检测策略，Default、OnPush(当输入属性值通过外部传入且发生改变时，才执行变化检测，从而更新视图，不执行变化检测，不能更新视图，变化检测用于更新视图，与ngDoCheck等钩子函数无关，ngDoCheck总是触发，父组件的变化检测机制不影响子组件的变化检测，父子组件各自独立
})

@Directive({
  selector: '[ngModel]:not([formControlName]):not([formControl])',
  host: {
    '(click)': 'onClick($event.target)',
    'role': 'button',
    '[class.pressed]': 'isPressed'
  },
  providers: [formControlBinding],
  exportAs: 'ngModel'  // 导出指令实例，使得可以在模板中引用指令的实例，如#i="ngModel"
})

@Pipe()
@Injectable()  // 标志着一个类（依赖者而非被依赖者）可以被一个注入器实例化。通常来讲，在试图实例化一个没有被标识为@Injectable()的类时候，注入器将会报告错误
@Inject(APP_CONFIG)  // let APP_CONFIG = new OpaqueToken('app.config');
@RouteConfig()  // 定义路由
@Optional()  // 依赖注入时，依赖可选非必须
@SkipSelf()  // 依赖注入时，跳过依赖自身，防止循环依赖
@Self()  // 依赖注入时，依赖自身
@Input()
@Output()
@ViewChild()  // read查询
@ViewChildren()  // QueryList<T>
@ContentChild()
@ContentChildren()
@HostListener()  // 为宿主元素添加事件监听， @HostListener('click', ['$event.target', ...])，@HostListener('document:click', ['$event'])
@HostBinding()  // 动态设置宿主元素的属性值，@HostBinding('attr.role') role = 'button'，@HostBinding('class.pressed') isPressed: boolean

ng-content  // select属性，root component中不能使用
ng-template  // ngTemplateOutlet属性，ngTemplateOutletContext属性（$implicit）

forwardRef  // 让我们可以在使用构造函数注入时，使用尚未定义的依赖对象类型（定义的class未提升），@Inject(forwardRef(() => Buffer)) private buffer
ChangeDetectorRef  // 组件的变化检测器的引用，markForCheck()（下一个周期，强制执行变化检测），detach()，reattach()，detectChanges()（ 从该组件到各个子组件执行一次变化检测）
ElementRef  // 封装不同平台下视图层中的native元素
ComponentRef  // 组件的引用
TemplateRef  // 模板的引用，TemplateRef实例中引用ElementRef（comment元素的封装），createEmbeddedView(null)返回embeddedViewRef
ViewRef  // 视图对象，表示angular视图元素
EmbeddedViewRef  // 内嵌视图，表示模板中定义的视图元素，rootNodes属性包含了模板的所有节点，通常与TemplateRef配合使用，继承自ViewRef
ViewContainerRef  // 表示一个视图容器，用于创建和管理内嵌视图（TemplateRef）或组件视图（ComponentRef），实例中引用ElementRef，createEmbeddedView(templateRef)简化通过模板创建视图，createComponent(...)

form  // form标签上，标注属性novalidate，禁用浏览器原生验证
模板驱动式表单  // FormsModule
ngForm  // 可通过#f="ngForm"，将ngForm实例赋值给变量f
ngModel  // 数据双向绑定，可通过#i="ngModel"，将ngModel实例赋值给变量i，<input [(ngModel)]="user.name"> == <input [ngModel]="user.name" (ngModelChange)="user.name = $event">
ngModelGroup  // 绑定model对象的嵌套属性名，可通过#g="ngModelGroup"，将ngModelGroup实例赋值给变量g
ngSubmit  // 输出属性，表单提交时触发
required
minlength
maxlength 
email 
pattern
...
响应式表单  // ReactiveFormsModule
FormControl  // 用于跟踪组件的值和验证状态
formControl  // 在模板中使用，绑定某FormControl实例
formControlName  // 在模板中使用，绑定FormGroup对象中对应的FormControl实例，此时input等组件可不指定name属性
FormGroup  
formGroup  // 在模板中使用，绑定某FormGroup实例
formGroupName  // 在模板中使用，绑定FormGroup对象的嵌套FormGroup实例
FormArray  // 需在FormGroup内部使用
formArrayName  // 在模板中使用，绑定FormGroup对象中对应的FormArray实例
FormBuilder  // group()，control()，array()等方法，方便创建FormGroup、FormControl、FormArray实例
ngSubmit
自定义验证器函数  // 可定义一个Directive，implements Validator，实现validate方法，参数AbstractControl，验证通过，返回null，不通过，返回一个只包含一个属性的对象如：{abc: boolean | string | Object ...} ，在模板中通过调用hasError('abc')判断是否通过，可以通过getError('abc', path?: string[])获取错误信息，path为该AbstractControl实例在FromGroup中的层级结构
同步验证器  // provide: NG_VALIDATORS， multi: true
异步验证器  // provide: NG_ASYNC_VALIDATORS， multi: true，监听AbstractControl实例的valueChanges，返回一个Observable对象 

动画
对于动态创建的component，调用destroy方法，:leave animation不触发。:leave，只能在host元素上触发

打包发布命令
ng build --prod --aot --base-href /users --deploy-url /public
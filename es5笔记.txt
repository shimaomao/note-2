闭包可以跨多层作用域捕获变量
函数调用模式本质上是调用全局对象的方法，即fn()本质上是global.fn()
函数调用模式，this默认指向global对象，使用'use strict';时，this指向undefined
new操作符可以把this绑定到当前生成的对象
如果通过bind方法绑定this指向，无法通过call，apply，bind方法改变this指向
call，apply，bind方法的第一个参数如果null，undefined，不传，this将会指向global对象（非严格模式下）
call，apply，bind方法的第一个参数如果是原始值，该原始值将被自动转换为对应的包装对象，如fn.call(1)，this将指向Number，并且这个Number的[[PrimitiveValue]]值为1，可以通过this.valueOf()取值

Function.prototype.myBind = function (ctx, ...args1) {
	let _this = this;
	let temp = function() {};  // 定义一个空的函数
	let boundFunc = function (...args2) {
		return _this.call(this instanceof temp ? this : ctx, ...args1, ...args2)
	};
	temp.prototype = this.prototype;  // 继承绑定函数原型的值
	boundFunc.prototype = new temp();  // 使用new操作符创建实例并赋值
	return boundFunc;
}

function myNew(Constructor, ...args) { 
	let newObj = {};
	newObj.__proto__ = Constructor.prototype;
	Constructor.call(newObj, ...args);  
	return newObj;
}

Array
forEach  // 不会遍历纯粹“占着官位吃空饷”的元素
map 
filter 
some
every  
indexOf  
lastIndexOf
reduce  // 如果initialValue缺省，则使用数组的第一个元素作为previousValue，同时currentValue往后排一位，相比有initialValue的少一次迭代。每一轮迭代的返回值作为下一轮的previousValue
reduceRight 

Object
Object.create(prototype[,descriptors]);  // 创建一个对象，并把prototype赋值为第一个参数，同时可以设置多个descriptors
Object.defineProperty(object, property, descriptor); 
Object.defineProperties(object, descriptors);
Object.getOwnPropertyDescriptor(object, property);
Object.getOwnPropertyNames(object);  // 获取所有的属性名，返回一个数组
Object.keys(object);  // 和getOwnPropertyNames方法类似，但是只获取所有的可枚举的属性
Object.preventExtensions(object);  // 用于锁住对象属性，使其不能够拓展，也就是不能增加新的属性，但是属性的值仍然可以更改，也可以把属性删除，Object.isExtensible用于判断对象是否可以被拓展
Object.isExtensible(object);
Object.seal(object);  // 用于把对象密封，也就是让对象既不可以拓展也不可以删除属性（每个属性的configurable被设为false）,但是属性值仍然可以修改，Object.isSealed用于判断对象是否被密封
Object.isSealed(object);
Object.freeze(object);  // 完全冻结对象，在seal的基础上，属性值也不可以修改（每个属性的wirtable被设为false），Object.isFrozen用于判断对象是否被冻结
Object.isFrozen(object);
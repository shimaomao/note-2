冯.诺依曼体系结构
控制器  // CC(central control)
运算器  // CA(central arithmetical)，包含通用寄存器
存储器  // M(memory)
输入  // I(input)
输出  // O(output)
外部记录介质  // R(outside recording mediumn)

x86处理器
x86-16 / IA-16
IA-32
x86-64

标量流水线处理器
超标量流水线处理器

指令体系结构
x86
mips

寄存器  // 每个bit位内部为一个触发器，触发器用于存储数据，如：D触发器
IR  // 指令寄存器，存放当前的指令
PC  // 程序计数器，存放下一条指令的地址
MAR  // 地址寄存器
MDR  // 数据寄存器
F  // 状态标志寄存器
R*  // 通用寄存器（包含段寄存器等）
CS  // 段寄存器，用于中断，CS:IP
IP  // 指令指针寄存器，用于中断
PSW  // 程序状态字寄存器
IR // 中断寄存器，每条指令执行后，扫描该寄存器，若存在中断，判断后，选择是否执行中断响应
...

总线
控制总线  // 向主存等，发出控制信号
地址总线  // 宽度决定寻址范围，从而决定主存的使用率，如宽度为32的地址，其寻址范围可达2的32次方
数据总线  // 宽度为主存位宽的整数倍，决定数据数据传输能力
系统总线
...

cpu
sram  // 不是通过行地址列地址访问，高速缓存，一级cache，分为指令数据高速缓存和数据高速缓存，目前一般各为32KB，二级cache，一般256KB，三级cache，多核共享，一般8MB，可读写，断电丢失数据，通过6个晶体管组成的电路保存一个bit位信息

主存
内部包含一个核心的存储阵列，有若干行若干列，通过行号+列号即为地址，由此可选中一个存储单元，存储单元的每个bit通过电容保存bit位信息
字存储单元  // (8 * n)bit，存放一个机器字的存储单元，字地址，如果计算机中可编址的最小单位是字存储单元，则该计算机称为按字编址的计算机
字节存储单元  // 8bit，存放一个字节的单元，字节地址，如果计算机中可编址的最小单位是字节，则该计算机称为按字节编址的计算机
dram  // 可读写，断电丢失数据，sdr sdram(single data rate)，ddr sdram(double data rate)

BIOS(baisc input output system)
rom  // 只读，断电不丢失数据

时序
时钟周期  // 主频决定
机器周期（cpu周期）  // 完成指令的某一个阶段所需要的时间。一个时钟周期为一个节拍（P），两个节拍为一个状态周期（S），8051中6个状态周期为一个机器周期，即8051中一个机器周期为十二个时钟周期
指令周期  // 完成执行一条指令所需要的时间。指令周期，由若干个机器周期组成，指令的复杂度越高，需要的机器周期数越高。需要一个机器周期的指令称为单周期指令，需要两个机器周期的指令成为双周期指令

晶体管
NMOS  // get端为1则连通
PMOS  // get端为1则关闭

ALU  // 算术逻辑单元
与门，或门，非门, 异或门，拼装成各种加法器，乘法器等
半加器  // 不处理进位
加法器  // 行波进位加法器，超前进位加法器

在计算机中，有符号数和无符号数都是以补码形式进行运算，无符号数永远是正数，补码即其本身，补码没有+0和-0之分，有符号和无符号只是程序定义的，计算机没有这个概念
对于4bit位，有符号数取值范围，-8 -> -1 -> 0 -> 7，用补码表示1000 -> 1111 -> 0000 -> 0111
溢出  // 有符号数加减，最高位进位与溢出无关，进位自动丢弃，两个正数相加为负数为溢出，两个负数相加为正数为溢出，其他情况都不是溢出，无符号数相加，最高位进位为溢出

中断  // 并不特指错误异常，类似事件
实模式
保护模式

I/O接口  // 内部包含寄存器，中断控制逻辑等
显卡

处理I/O
程序控制  // cpu不停的询问，cpu处理I/O
中断控制  // 中断请求，cpu处理I/O
直接存储器访问(DMA, direct memory access)  // DMAC处理I/O，完成后向cpu发送中断请求

DOS  // 早期的操作系统

几个概念
用户空间与内核空间  // 为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间
进程切换  // 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行
进程的阻塞  // 正在执行的进程，由于期待的某些事件未发生，则由程序自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态，进程的阻塞是进程自身的一种主动行为
文件描述符fd  // 计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念
缓存I/O  // 又称作标准I/O，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。当一个read操作发生时，它会经历两个阶段，1、 等待数据准备，2、将数据从内核拷贝到进程中

linux网络I/O模式
阻塞I/O  // blocking I/O，在linux中，默认情况下所有的socket都是blocking，blocking I/O的特点就是在IO执行的两个阶段都被block了
非阻塞I/O  // noblocking I/O，nonblocking I/O的特点是用户进程需要不断的主动询问kernel数据好了没有，在kernel还准备数据的情况下会立刻返回
I/O多路复用  // I/O multiplexing，又称为event driven I/O，有三种机制select、poll、epoll，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。当用户进程调用了select，那么整个进程会被block，而同时，kernel会监视所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回
信号驱动I/O  // signal driven I/O，不常用
异步I/O  // asynchronous I/O，IO operation的时候不会将process阻塞，不常用，（windows iocp？），用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了
同步I/O  // synchronous I/O，IO operation的时候会将process阻塞，阻塞I/O、非阻塞I/O、I/O多路复用、信号驱动I/O都属于同步I/O

I/O多路复用的三种机制select、poll、epoll
I/O多路复用就是通过一种机制，让一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现（kernel）会负责把数据从内核拷贝到用户空间
select  // 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024
poll  // poll并没有最大数量限制，但是数量过大后性能也会下降，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket
epoll  // 在2.6内核中提出，select和poll的增强版本，epoll更加灵活，没有描述符限制，epoll使用一个文件描述符管理多个描述符，epoll I/O的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的，只有就绪的fd才会执行回调函数
  epoll有两种工作模式：
    LT模式  // level trigger，水平触发，默认，同时支持block和no-block socket，当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件
    ET模式  // edge trigger，边缘触发，高速工作方式，只支持no-block socket，当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件
如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll
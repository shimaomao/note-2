变量绑定
模式（patterns）
类型注解（type annotations）
可变性（mutability）
初始化绑定（initializing bindings） //使用之前必须初始化
作用域（scope）
隐藏（shadowing） //重新声明并初始化变量，来覆盖前一个变量绑定

函数
定义函数时，必须为函数参数声明类型，这是一个全推断与无推断的最佳平衡
rust函数只能返回一个值 //->
rust是一个基于表达式的语言，分号与其它基于“大括号和分号”的语言不同，在rust中分号来分隔各个表达式
表达式与语句
表达式返回一个值，而语句不是
rust中语句有两种类型：声明语句和表达式语句（目的是把任何表达式变为语句），其余都是表达式
提早返回（early returns）
发散函数（diverging function）
发散函数并不返回，它拥有一个类型!，代表“发散”
控制台想获取更多的信息，配置rust环境RUST_BACKTRACE=1
函数指针
let f: fn(i32) -> i32 = someFunc; //此时不需要类型推断
let f = someFunc; //此时需要类型推断

原声类型
bool
char //单引号，rust中一个字符占4个字节
数字类型
有符号，无符号，定长，不定长，整型，浮点型
i8
i16
i32 //整型默认
i64
u8
u16
u32
u64 //浮点型默认
isize //依赖底层指针大小，有符号
usize //依赖底层指针大小，无符号
f32 //单精度
f64 //双精度
有符号数，采用补码形式表示
计算机中的有符号数有三种表示方法，即原码、反码和补码，符号位0表示正，1表示负
正数的补码是其本身
求－5对应的补码：
-5对应正数5（00000101） -> 所有位取反（11111010） -> 加1(11111011)
数组，定长的相同类型的元素列表，数组默认是不可变的
数组的类型是[T; N]，T为泛型标记，N代表数组的长度
arr.len(); //获取数组元素数量
let a = [0; 20]; //将数组中每一个元素初始化为相同值的简写
切片(slices)是对一个数组的引用，通过组合&和[]来创建一个切片，如&arr[..],&arr[1..4] //复制1，2，3元素
切片的类型是&[T]，T为泛型
原始字符串类型，str，不定长类型
元组(tuples)，固定大小的有序列表，可用作模式匹配
let x: (i32, &str) = (1, "hello"); //类型，(i32, &str)，&str是一个字符串切片
可以一个逗号来消除一个单元素元组(0,)和一个括号中的值(0)的歧义
元组索引（Tuple Indexing），tuple.0,tuple.1...元组索引使用.而不是[]
函数，函数的类型为!
let x: fn(i32) -> i32 = foo;

注释
// 行注释
/// 文档注释，内建markdown标记支持
//! 文档注释，用来注释包含它的项（crate，模块或者函数），而不是注释位于它之后的项 //crate，箱

if语句
if x == 5 {

} else if x == 6 {

} else {

}
if语句其实是一个表达式
let y = if x == 5 { 10 } else { 15 }; // y: i32
一个没有else的if总是返回()作为返回值

循环
loop
loop { //无限循环，直到一些终止语句被执行

}
while
while judge { //不确定应该循环多少次

}
for
for var in expression { //循环特定的次数，expression是一个迭代器如1..10（不包括上限值10）

}
enumerate方法，记录已经循环了多少次
for (i, j) in (5..10).enumerate() {

}
break; //loop, while, for
continue; //while, for
循环标签，主要用于嵌套循环的流程控制
'test:for i in 0..10 { //注意，标签名单引号并未闭合
  continue 'test;
}

所有权（ownership）
对于任何给定的资源都正好（只）有一个绑定与之对应，当一个绑定离开作用域，它们绑定的资源就会释放
copy特性
基本类型（如数字，bool）都实现了copy特性，因此它们的所有权并不遵循“所有权规则”
可通过函数返回值，交还所有权，也可以通过借用，交还所有权

引用和借用
&T类型为一个引用，它借用了该资源的所有权，一个借用变量的绑定在它离开作用域时并不释放资源，因此可再次使用原始的绑定
普通引用是不可变的，就像绑定一样
&mut T类型，可变引用，允许改变借用的资源
＊var 访问变量引用的资源
任何借用必须位于比拥有者更小的作用域
可以有一个或另一个这两种类型（&T或&mut T）的借用，不过不能同时拥有它们（&T或&mut T）

生命周期
生命周期，定义了一个引用有效的作用域
引用指向一个无效的资源，这叫做悬垂指针（dangling pointer）或者“释放后使用”
fn bar<'a>(x: &'a mut i32) {
}
'a读作“生命周期 a”
用<>声明了生命周期，一个函数可以在<>之间有“泛型参数”，生命周期也是其中一种
'static，该作用域是特殊的，它代表某样东西具有横跨整个程序的生命周期

可变性
mut是模式的一部分
let (mut x, y) = (5, 6);
fn foo(mut x: i32) {}
内部可变性 vs 外部可变性
字段级别可变性，你不能拥有一个一些字段可变而一些字段不可变的结构体

结构体
struct Point { //根据传统，结构体使用大写字母开头，并使用驼峰命名法
  x: i32,
  y: i32
}
访问字段，通过圆点记法，如point.x
rust在语言级别不支持字段可变性
一个包含..的struct表明你想要使用一些其它结构体的拷贝的一些值
let mut point = Point3d { x: 0, y: 0, z: 0 };
point = Point3d { y: 1, .. point };
元组结构体
元组结构体有一个名字，不过它的字段没有
struct Color(i32, i32, i32);
let black = Color(0, 0, 0);
当元组结构体，只有一个元素时，我们称之为新类型（newtype），因为创建了一个与元素类似的类型
struct Inches(i32);
let length = Inches(10);
let Inches(integer_length) = length; //模式匹配
类单元结构体（Unit-like structs）
类单元结构体，定义一个没有任何成员的结构体，它与一个空元组()类似
